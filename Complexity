- input ≥ 0
    - 입력값(n)은 항상 0보다 크다.
- functions do more work for more input
    - 함수는 많은 입력값이 있을 때 더 많은 작업을 하게된다.
- drop all constants
    - 시간복잡도에서는 모든 상수를 삭제한다.
    - 3n ⇒ n
- ignore lower order terms
    - 낮은 차수의 항들은 무시한다.
    - n^3 + n^2 +n + 5 ⇒ n^3
- ignore the base of logs
    - 시간 복잡도 함수가 log 함수를 포함할 경우 믿은 무시한다.
    - math.log(2) ⇒ what is mean in java? what is base of logs? ⇒ ln(2) / ln(10) ⇒ log n algorithm
- 2n = O(n) = 2n equals 2n 은 O(n)에 속한다.
    - 등호를 사용하여 표현한다.

- c- constant time
- log n - tree
- n - oce per item
- n^2 = compare all v all
- n! = traveling sales

- 생각해보기
    - 시간복잡도가 1이거나 n인 것은 각각 무엇을 의미할까?

        1인것은 상수 시간에 작동하는 알고리즘 복잡도, 한번의 계산만 하면 되는 경우. 

        n은 각각의 요소마다 한 번씩 작업을 하는 경우의 복잡도이다. 

# Big Oh Notation(빅오 표기법)

- 알고리즘의 효율성을 표시하는 표기법

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e73f20b-4b14-4731-ac10-ab13f9e9ce36/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e73f20b-4b14-4731-ac10-ab13f9e9ce36/Untitled.png)

- O : same or faster
- little o : faster
- Θ : same rate
- Ω : same or slower
- ω(little omega) : slower

- 생각해보기
    - 빅 오 표기법을 각각 부등호에 대응하면 어떤 것을까?
        - O : same or faster ≤
        - little o : faster <
        - Θ : same rate =
        - Ω : same or slower ≥
        - ω(little omega) : slower >
    - 빅 오 표기법의 O는 무엇의 약자일까?
        - Oh

# 1-4 Big Oh Notation Example

- 생각해보기
    - 문제 1에서 n=1을 대입하면 어떻게 되나요? 적당히 큰 수를 대입해야 하는 이유는 무엇인가요?
    - 알고리즘의 시간 복잡도를 비교할 때는 n이 큰 경우(무한에 가까워지는 경우)를 가정해야 한다. 1처럼 작은 수를 대입한 경우 실제시간 복잡도와는 동떨어진 결과가 나올 수 있다.
